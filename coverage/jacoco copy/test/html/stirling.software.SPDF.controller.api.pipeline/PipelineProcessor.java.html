<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PipelineProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stirling-PDF</a> &gt; <a href="index.source.html" class="el_package">stirling.software.SPDF.controller.api.pipeline</a> &gt; <span class="el_source">PipelineProcessor.java</span></div><h1>PipelineProcessor.java</h1><pre class="source lang-java linenums">package stirling.software.SPDF.controller.api.pipeline;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import io.github.pixee.security.Filenames;
import io.github.pixee.security.ZipSecurity;

import jakarta.servlet.ServletContext;
import stirling.software.SPDF.SPdfApplication;
import stirling.software.SPDF.model.PipelineConfig;
import stirling.software.SPDF.model.PipelineOperation;
import stirling.software.SPDF.model.Role;

@Service
<span class="nc" id="L49">public class PipelineProcessor {</span>

<span class="nc" id="L51">    private static final Logger logger = LoggerFactory.getLogger(PipelineProcessor.class);</span>

    @Autowired private ApiDocService apiDocService;

    @Autowired(required = false)
    private UserServiceInterface userService;

    @Autowired private ServletContext servletContext;

    private String getApiKeyForUser() {
<span class="nc bnc" id="L61" title="All 2 branches missed.">        if (userService == null) return &quot;&quot;;</span>
<span class="nc" id="L62">        return userService.getApiKeyForUser(Role.INTERNAL_API_USER.getRoleId());</span>
    }

    private String getBaseUrl() {
<span class="nc" id="L66">        String contextPath = servletContext.getContextPath();</span>
<span class="nc" id="L67">        String port = SPdfApplication.getStaticPort();</span>

<span class="nc" id="L69">        return &quot;http://localhost:&quot; + port + contextPath + &quot;/&quot;;</span>
    }

    List&lt;Resource&gt; runPipelineAgainstFiles(List&lt;Resource&gt; outputFiles, PipelineConfig config)
            throws Exception {

<span class="nc" id="L75">        ByteArrayOutputStream logStream = new ByteArrayOutputStream();</span>
<span class="nc" id="L76">        PrintStream logPrintStream = new PrintStream(logStream);</span>

<span class="nc" id="L78">        boolean hasErrors = false;</span>

<span class="nc bnc" id="L80" title="All 2 branches missed.">        for (PipelineOperation pipelineOperation : config.getOperations()) {</span>
<span class="nc" id="L81">            String operation = pipelineOperation.getOperation();</span>
<span class="nc" id="L82">            boolean isMultiInputOperation = apiDocService.isMultiInput(operation);</span>

<span class="nc" id="L84">            logger.info(</span>
                    &quot;Running operation: {} isMultiInputOperation {}&quot;,
                    operation,
<span class="nc" id="L87">                    isMultiInputOperation);</span>
<span class="nc" id="L88">            Map&lt;String, Object&gt; parameters = pipelineOperation.getParameters();</span>
<span class="nc" id="L89">            List&lt;String&gt; inputFileTypes = apiDocService.getExtensionTypes(false, operation);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">            if (inputFileTypes == null) {</span>
<span class="nc" id="L91">                inputFileTypes = new ArrayList&lt;String&gt;(Arrays.asList(&quot;ALL&quot;));</span>
            }
            // List outputFileTypes = apiDocService.getExtensionTypes(true, operation);

<span class="nc" id="L95">            String url = getBaseUrl() + operation;</span>

<span class="nc" id="L97">            List&lt;Resource&gt; newOutputFiles = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">            if (!isMultiInputOperation) {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">                for (Resource file : outputFiles) {</span>
<span class="nc" id="L100">                    boolean hasInputFileType = false;</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">                    for (String extension : inputFileTypes) {</span>
<span class="nc bnc" id="L102" title="All 4 branches missed.">                        if (&quot;ALL&quot;.equals(extension) || file.getFilename().endsWith(extension)) {</span>
<span class="nc" id="L103">                            hasInputFileType = true;</span>
<span class="nc" id="L104">                            MultiValueMap&lt;String, Object&gt; body = new LinkedMultiValueMap&lt;&gt;();</span>
<span class="nc" id="L105">                            body.add(&quot;fileInput&quot;, file);</span>

<span class="nc bnc" id="L107" title="All 2 branches missed.">                            for (Entry&lt;String, Object&gt; entry : parameters.entrySet()) {</span>
<span class="nc" id="L108">                                body.add(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L109">                            }</span>

<span class="nc" id="L111">                            ResponseEntity&lt;byte[]&gt; response = sendWebRequest(url, body);</span>

                            // If the operation is filter and the response body is null or empty,
                            // skip
                            // this
                            // file
<span class="nc bnc" id="L117" title="All 2 branches missed.">                            if (operation.startsWith(&quot;filter-&quot;)</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                                    &amp;&amp; (response.getBody() == null</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">                                            || response.getBody().length == 0)) {</span>
<span class="nc" id="L120">                                logger.info(&quot;Skipping file due to failing {}&quot;, operation);</span>
<span class="nc" id="L121">                                continue;</span>
                            }

<span class="nc bnc" id="L124" title="All 2 branches missed.">                            if (!response.getStatusCode().equals(HttpStatus.OK)) {</span>
<span class="nc" id="L125">                                logPrintStream.println(&quot;Error: &quot; + response.getBody());</span>
<span class="nc" id="L126">                                hasErrors = true;</span>
<span class="nc" id="L127">                                continue;</span>
                            }
<span class="nc" id="L129">                            processOutputFiles(operation, response, newOutputFiles);</span>
                        }
<span class="nc" id="L131">                    }</span>

<span class="nc bnc" id="L133" title="All 2 branches missed.">                    if (!hasInputFileType) {</span>
<span class="nc" id="L134">                        logPrintStream.println(</span>
                                &quot;No files with extension &quot;
<span class="nc" id="L136">                                        + String.join(&quot;, &quot;, inputFileTypes)</span>
                                        + &quot; found for operation &quot;
                                        + operation);
<span class="nc" id="L139">                        hasErrors = true;</span>
                    }
<span class="nc" id="L141">                }</span>

            } else {
                // Filter and collect all files that match the inputFileExtension
                List&lt;Resource&gt; matchingFiles;
<span class="nc bnc" id="L146" title="All 2 branches missed.">                if (inputFileTypes.contains(&quot;ALL&quot;)) {</span>
<span class="nc" id="L147">                    matchingFiles = new ArrayList&lt;&gt;(outputFiles);</span>
                } else {
<span class="nc" id="L149">                    final List&lt;String&gt; finalinputFileTypes = inputFileTypes;</span>
<span class="nc" id="L150">                    matchingFiles =</span>
<span class="nc" id="L151">                            outputFiles.stream()</span>
<span class="nc" id="L152">                                    .filter(</span>
                                            file -&gt;
<span class="nc" id="L154">                                                    finalinputFileTypes.stream()</span>
<span class="nc" id="L155">                                                            .anyMatch(file.getFilename()::endsWith))</span>
<span class="nc" id="L156">                                    .collect(Collectors.toList());</span>
                }

                // Check if there are matching files
<span class="nc bnc" id="L160" title="All 2 branches missed.">                if (!matchingFiles.isEmpty()) {</span>
                    // Create a new MultiValueMap for the request body
<span class="nc" id="L162">                    MultiValueMap&lt;String, Object&gt; body = new LinkedMultiValueMap&lt;&gt;();</span>

                    // Add all matching files to the body
<span class="nc bnc" id="L165" title="All 2 branches missed.">                    for (Resource file : matchingFiles) {</span>
<span class="nc" id="L166">                        body.add(&quot;fileInput&quot;, file);</span>
<span class="nc" id="L167">                    }</span>

<span class="nc bnc" id="L169" title="All 2 branches missed.">                    for (Entry&lt;String, Object&gt; entry : parameters.entrySet()) {</span>
<span class="nc" id="L170">                        body.add(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L171">                    }</span>

<span class="nc" id="L173">                    ResponseEntity&lt;byte[]&gt; response = sendWebRequest(url, body);</span>

                    // Handle the response
<span class="nc bnc" id="L176" title="All 2 branches missed.">                    if (response.getStatusCode().equals(HttpStatus.OK)) {</span>
<span class="nc" id="L177">                        processOutputFiles(operation, response, newOutputFiles);</span>
                    } else {
                        // Log error if the response status is not OK
<span class="nc" id="L180">                        logPrintStream.println(</span>
<span class="nc" id="L181">                                &quot;Error in multi-input operation: &quot; + response.getBody());</span>
<span class="nc" id="L182">                        hasErrors = true;</span>
                    }
<span class="nc" id="L184">                } else {</span>
<span class="nc" id="L185">                    logPrintStream.println(</span>
                            &quot;No files with extension &quot;
<span class="nc" id="L187">                                    + String.join(&quot;, &quot;, inputFileTypes)</span>
                                    + &quot; found for multi-input operation &quot;
                                    + operation);
<span class="nc" id="L190">                    hasErrors = true;</span>
                }
            }
<span class="nc" id="L193">            logPrintStream.close();</span>
<span class="nc" id="L194">            outputFiles = newOutputFiles;</span>
<span class="nc" id="L195">        }</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (hasErrors) {</span>
<span class="nc" id="L197">            logger.error(&quot;Errors occurred during processing. Log: {}&quot;, logStream.toString());</span>
        }

<span class="nc" id="L200">        return outputFiles;</span>
    }

    private ResponseEntity&lt;byte[]&gt; sendWebRequest(String url, MultiValueMap&lt;String, Object&gt; body) {
<span class="nc" id="L204">        RestTemplate restTemplate = new RestTemplate();</span>

        // Set up headers, including API key

<span class="nc" id="L208">        HttpHeaders headers = new HttpHeaders();</span>
<span class="nc" id="L209">        String apiKey = getApiKeyForUser();</span>
<span class="nc" id="L210">        headers.add(&quot;X-API-Key&quot;, apiKey);</span>
<span class="nc" id="L211">        headers.setContentType(MediaType.MULTIPART_FORM_DATA);</span>

        // Create HttpEntity with the body and headers
<span class="nc" id="L214">        HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(body, headers);</span>

        // Make the request to the REST endpoint
<span class="nc" id="L217">        return restTemplate.exchange(url, HttpMethod.POST, entity, byte[].class);</span>
    }

    public static String removeTrailingNaming(String filename) {
        // Splitting filename into name and extension
<span class="nc" id="L222">        int dotIndex = filename.lastIndexOf(&quot;.&quot;);</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (dotIndex == -1) {</span>
            // No extension found
<span class="nc" id="L225">            return filename;</span>
        }
<span class="nc" id="L227">        String name = filename.substring(0, dotIndex);</span>
<span class="nc" id="L228">        String extension = filename.substring(dotIndex);</span>

        // Finding the last underscore
<span class="nc" id="L231">        int underscoreIndex = name.lastIndexOf(&quot;_&quot;);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (underscoreIndex == -1) {</span>
            // No underscore found
<span class="nc" id="L234">            return filename;</span>
        }

        // Removing the last part and reattaching the extension
<span class="nc" id="L238">        return name.substring(0, underscoreIndex) + extension;</span>
    }

    private List&lt;Resource&gt; processOutputFiles(
            String operation, ResponseEntity&lt;byte[]&gt; response, List&lt;Resource&gt; newOutputFiles)
            throws IOException {
        // Define filename
        String newFilename;
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (operation.contains(&quot;auto-rename&quot;)) {</span>
            // If the operation is &quot;auto-rename&quot;, generate a new filename.
            // This is a simple example of generating a filename using current timestamp.
            // Modify as per your needs.

<span class="nc" id="L251">            newFilename = extractFilename(response);</span>
        } else {
            // Otherwise, keep the original filename.
<span class="nc" id="L254">            newFilename = removeTrailingNaming(extractFilename(response));</span>
        }

        // Check if the response body is a zip file
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (isZip(response.getBody())) {</span>
            // Unzip the file and add all the files to the new output files
<span class="nc" id="L260">            newOutputFiles.addAll(unzip(response.getBody()));</span>
        } else {
<span class="nc" id="L262">            Resource outputResource =</span>
<span class="nc" id="L263">                    new ByteArrayResource(response.getBody()) {</span>
                        @Override
                        public String getFilename() {
<span class="nc" id="L266">                            return newFilename;</span>
                        }
                    };
<span class="nc" id="L269">            newOutputFiles.add(outputResource);</span>
        }

<span class="nc" id="L272">        return newOutputFiles;</span>
    }

    public String extractFilename(ResponseEntity&lt;byte[]&gt; response) {
<span class="nc" id="L276">        String filename = &quot;default-filename.ext&quot;; // Default filename if not found</span>

<span class="nc" id="L278">        HttpHeaders headers = response.getHeaders();</span>
<span class="nc" id="L279">        String contentDisposition = headers.getFirst(HttpHeaders.CONTENT_DISPOSITION);</span>

<span class="nc bnc" id="L281" title="All 4 branches missed.">        if (contentDisposition != null &amp;&amp; !contentDisposition.isEmpty()) {</span>
<span class="nc" id="L282">            String[] parts = contentDisposition.split(&quot;;&quot;);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">            for (String part : parts) {</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                if (part.trim().startsWith(&quot;filename&quot;)) {</span>
                    // Extracts filename and removes quotes if present
<span class="nc" id="L286">                    filename = part.split(&quot;=&quot;)[1].trim().replace(&quot;\&quot;&quot;, &quot;&quot;);</span>
<span class="nc" id="L287">                    filename = URLDecoder.decode(filename, StandardCharsets.UTF_8);</span>

<span class="nc" id="L289">                    break;</span>
                }
            }
        }

<span class="nc" id="L294">        return filename;</span>
    }

    List&lt;Resource&gt; generateInputFiles(File[] files) throws Exception {
<span class="nc bnc" id="L298" title="All 4 branches missed.">        if (files == null || files.length == 0) {</span>
<span class="nc" id="L299">            logger.info(&quot;No files&quot;);</span>
<span class="nc" id="L300">            return null;</span>
        }

<span class="nc" id="L303">        List&lt;Resource&gt; outputFiles = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">        for (File file : files) {</span>
<span class="nc" id="L306">            Path path = Paths.get(file.getAbsolutePath());</span>
<span class="nc" id="L307">            logger.info(&quot;Reading file: &quot; + path); // debug statement</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (Files.exists(path)) {</span>
<span class="nc" id="L310">                Resource fileResource =</span>
<span class="nc" id="L311">                        new ByteArrayResource(Files.readAllBytes(path)) {</span>
                            @Override
                            public String getFilename() {
<span class="nc" id="L314">                                return file.getName();</span>
                            }
                        };
<span class="nc" id="L317">                outputFiles.add(fileResource);</span>
<span class="nc" id="L318">            } else {</span>
<span class="nc" id="L319">                logger.info(&quot;File not found: &quot; + path);</span>
            }
        }
<span class="nc" id="L322">        logger.info(&quot;Files successfully loaded. Starting processing...&quot;);</span>
<span class="nc" id="L323">        return outputFiles;</span>
    }

    List&lt;Resource&gt; generateInputFiles(MultipartFile[] files) throws Exception {
<span class="nc bnc" id="L327" title="All 4 branches missed.">        if (files == null || files.length == 0) {</span>
<span class="nc" id="L328">            logger.info(&quot;No files&quot;);</span>
<span class="nc" id="L329">            return null;</span>
        }

<span class="nc" id="L332">        List&lt;Resource&gt; outputFiles = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L334" title="All 2 branches missed.">        for (MultipartFile file : files) {</span>
<span class="nc" id="L335">            Resource fileResource =</span>
<span class="nc" id="L336">                    new ByteArrayResource(file.getBytes()) {</span>
                        @Override
                        public String getFilename() {
<span class="nc" id="L339">                            return Filenames.toSimpleFileName(file.getOriginalFilename());</span>
                        }
                    };
<span class="nc" id="L342">            outputFiles.add(fileResource);</span>
        }
<span class="nc" id="L344">        logger.info(&quot;Files successfully loaded. Starting processing...&quot;);</span>
<span class="nc" id="L345">        return outputFiles;</span>
    }

    private boolean isZip(byte[] data) {
<span class="nc bnc" id="L349" title="All 4 branches missed.">        if (data == null || data.length &lt; 4) {</span>
<span class="nc" id="L350">            return false;</span>
        }

        // Check the first four bytes of the data against the standard zip magic number
<span class="nc bnc" id="L354" title="All 8 branches missed.">        return data[0] == 0x50 &amp;&amp; data[1] == 0x4B &amp;&amp; data[2] == 0x03 &amp;&amp; data[3] == 0x04;</span>
    }

    private List&lt;Resource&gt; unzip(byte[] data) throws IOException {
<span class="nc" id="L358">        logger.info(&quot;Unzipping data of length: {}&quot;, data.length);</span>
<span class="nc" id="L359">        List&lt;Resource&gt; unzippedFiles = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L361">        try (ByteArrayInputStream bais = new ByteArrayInputStream(data);</span>
<span class="nc" id="L362">                ZipInputStream zis = ZipSecurity.createHardenedInputStream(bais)) {</span>

            ZipEntry entry;
<span class="nc bnc" id="L365" title="All 2 branches missed.">            while ((entry = zis.getNextEntry()) != null) {</span>
<span class="nc" id="L366">                ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L367">                byte[] buffer = new byte[1024];</span>
                int count;

<span class="nc bnc" id="L370" title="All 2 branches missed.">                while ((count = zis.read(buffer)) != -1) {</span>
<span class="nc" id="L371">                    baos.write(buffer, 0, count);</span>
                }

<span class="nc" id="L374">                final String filename = entry.getName();</span>
<span class="nc" id="L375">                Resource fileResource =</span>
<span class="nc" id="L376">                        new ByteArrayResource(baos.toByteArray()) {</span>
                            @Override
                            public String getFilename() {
<span class="nc" id="L379">                                return filename;</span>
                            }
                        };

                // If the unzipped file is a zip file, unzip it
<span class="nc bnc" id="L384" title="All 2 branches missed.">                if (isZip(baos.toByteArray())) {</span>
<span class="nc" id="L385">                    logger.info(&quot;File {} is a zip file. Unzipping...&quot;, filename);</span>
<span class="nc" id="L386">                    unzippedFiles.addAll(unzip(baos.toByteArray()));</span>
                } else {
<span class="nc" id="L388">                    unzippedFiles.add(fileResource);</span>
                }
<span class="nc" id="L390">            }</span>
        }

<span class="nc" id="L393">        logger.info(&quot;Unzipping completed. {} files were unzipped.&quot;, unzippedFiles.size());</span>
<span class="nc" id="L394">        return unzippedFiles;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>